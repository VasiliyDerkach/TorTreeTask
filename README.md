Приложение "Редактор бизнес-процессов"
Версия с Tortoise ORM

Обзор проекта

Предлагается приложения для работы с базами данных с использованием в качестве ORM Tortoise ORM. Разработаны также отдельные версии, с использованием ORM SQLAlchemy и Django ORM.
Одной из целей проекта является среавнение характеристик перечисленных ORM.
Приложение - заготовка под реализацию бизнес-процессов со списком задач и связанных с ними контактов с ролями (исполнитель, руководитель, клиент и т.п.). 
Задачи должны быть связаны между собой исходящими и входящими взаимосвязями (стрелками) любой сложности. Это необходимо для последующего определения последовательности и актуализации задач. 
Для возможности сравнения ORM, для всех трех приложений предполагается одинаковый функционал.

Требуется установка библиотек:
Django, Tortoise, uuid, datetime, aerich 

Структура проекта.
Проект включает в себя следующую структуру:

Реляционная модель базы данных.

Для построения базы данных для всех трех приложений выбрана СУБД SQLite. 
Таблица задач Tasks содержит поля данных: id – первичный индекс в формате UUID, заголовок задачи –title, дата начала выполнения задачи start типа дата, дата завершения задачи end типа дата.
Таблица Contacts содержит поля данных: id – первичный индекс в формате UUID, ФИО контакта – строковые поля last_name, first_name, second_name.
Таблица взаимосвязей сущностей Univers_list по принципу многие ко многим, содержит поля данных:
целочисленное поле id - ключевое поле для определения уникального указателя на запись таблицы, используемое для удаления и редактирования данных таблицы.
id_out - текстовое поле для хранения указателя на id задачи (в формате uuid), от которой исходит взаимосвязь с другой задачей или с констактом (исходящая стрелка).
id_in - текстовое поле для хранения указателя на id задачи или контакта (в формате uuid), в которую входит взаимосвязь с другой задачей (входящая стрелка).
 Role - текстовое поле для хранения данных о характере взаимосвязи задачи и контакта (исполнитель, контролер и т.п.).
 Для взаимосвязи задач значение по умолчанию 'arrow'.
 num_in_link - целочисленное поле для автоматической нумерации записей таблицы взаимсвязей для задачи с id=id_out  (нумерация исходящих стрелок для одной задачи).
 Для взаимсвязи задач и конктактов   num_in_link=0
 Поле предназначено для расширения функционала приложения в будущем. Например, сложный алгоритм определения актуальности
 задачи по входящим в нее нумерованным стрелкам по типу Arrow[1] and (Arrow[2] or Arrow[3])
При расширении проекта в будущем предполагается использовать данную таблицу связей для связывания задач с новыми типами сущностей: документы, данные о доступе пользователей к задачам и т.п.
Так предлагается не нагружать структуру базы данных таблицами связей по каждой отдельной категории связей таблиц, то в моделях данных приложения не используется встроенные возможности построения связей многие ко многим. 
Также стандартные средства многие ко многим затрудняют связывание между собой записей данных внутри одной таблицы (в нашем случае задача к задаче).
Формат ключа UUID был выбран, как более универсальный, позволяющий упростить в будущем возможное взаимодействие приложения с другими приложениями по API, 
а также этот формат упрощает работу с таблицей связей Univers_list, так как не обязательно указывать между какими таблицами установлена конкретная взаимосвязь.

Шаблоны страниц
- main.html - шаблон главной страницы проекта, просмотр списка задач и выполнение операций с задачами. Представление MainPage.
- card_contact.html – шаблон предназначен для стандартного редактирования записи в таблице контактов Contacts.
- card_task.html – шаблон предназначен для редактирования данных взаимосвязей между задачами. Представление VCardTask.
- contacts.html шаблон предназначен для вывода страницы со списком контактов и выполнения операций с ними. Представление PageContacts.
- create_contact – шаблон предназначен для создания нового контакта в таблице Contacts. Представление VCreateContact.
- create_task.html – шаблон предназначен для создания новой задачи в таблице Tasks. Представление VCreateTask.
- edit_task.html – шаблон предназначен для редактирования записи в таблице задач Tasks.
- task_conttacts.html – шаблон предназначен для редактирования данных взаимосвязей между задачами и контактами. Представление VContactsTask.
 
Реализация функций проекта, не относящихся к ORM
Все функции проекта, не относящиеся к различным ORM, реализованы на FrameWork Django, шаблоны реализованы или через Django.Form или HTML.

Главная страница.
Страница показывает список всех задач и данных ее полей.
Элемент поиска задач с кнопкой «Найти задачи» позволяет фильтровать список задач по наличию в их заголовке определенного контекста в любой части строки.
 
Напротив данных каждой задачи реализованы следующие кнопки:
Ссылка через заголовок задачи - переход на страницу редактирования взаимосвязей выбранной задачи с другими задачами (подробней в разделе соответствующей страницы);
-х- удаляет выбранную задачу;
-> - переход на страницу редактирования полей данных задачи;
<> - переход на страницу редактирования взаимосвязей выбранной задачи с контактами и их роли (подробней в разделе соответствующей страницы).
В верхней части страницы реализовано меню для перехода на страницу со списком контактов, на страницы создания новых задач и контактов.

Страница редактирования взаимосвязей выбранной задачи с другими задачами.
 
Вверху страницы указаны данные выбранной задачи. Реализованы два списка задач: список связанных с выбранной задачей других задач (исходящие взаимосвязи по полю Univers_list.id_in) и список несвязанных с выбранной 
задачей других задач.
Для обоих списков реализован отдельный поиск задач по наличию контекста в заголовке задач. В поле ввода вводится контекст и нажимается кнопка «Найти».
Реализована логика, что задача не может быть связана сама с собой и не может дважды связываться с другой задачей в одно направлении «стрелки». Поэтому из списка несвязанных задач делаются соотвествующие исключения.
Напротив каждой несвязанной задачи реализована кнопка обозначенная -->, которая переводит задачу в список связанных задач после обновления страницы.
В списках задач, связанных с выбранной задачей, реализована кнопка обозначенная –x-. Данная кнопка удаляет связанность задач и соответствующая задача переходит в список несвязанных при обновлении страницы.
Вверху страницы есть ссылка для возвращения на главную страницу.

Страница редактирования взаимосвязей выбранной задачи с контактами.
 
Вверху страницы указаны данные выбранной задачи. Реализованы два списка контактов: список контактов, связанных с выбранной задачей (исходящие взаимосвязи по полю Univers_list.id_in) и список несвязанных с выбранной задачей контактов.
Для обоих списков реализован отдельный поиск контактов по наличию контекста в фамилии. В поле ввода вводится контекст и нажимается кнопка «Найти».
В отличие от предыдущей страницы, контакт может быть несколько раз связан с задачей, т.к. могу быть разные роли. 
Напротив каждого несвязанного контакта реализована кнопка обозначенная -->, которая переводит контакт в список связанных контактов (с пустой по умолчанию ролью) после обновления страницы.
В списках контактов, связанных с выбранной задачей, реализована кнопка обозначенная –x-. Данная кнопка удаляет связанность задачи с контактом по соответствующей роли.
В списках связанных с задачей контактов реализован выпадающий список с возможными ролями взаимосвязи (исполнительн, цель задачи, руководитель и т.п.) после выбора соответствующей роли, 
для изменения в базе данных необходимо нажать на кнопку обозначенную «U» и обновить страницу.
Вверху страницы есть ссылка для возвращения на главную страницу.

Страница списка контактов.
 
В меню страницы реализованы возврат на главную страницу и переход на страницу создания нового контакта.
ФИО контакта в списке является ссылкой для перехода на страницу редактирования данных полей контакта.
Рядом с каждым контактом в списке реализована кнопка –x- для удления контакта.
Стандартные страницы работы с данными.
Страница редактирования данных полей контакта.
 
Стандартные страницы:
Страница редактирования данных полей задачи (даты редактируются в формате 31.12.2023).
Страница редактирования данных полей контакта.
Страница (форма) создания нового контакта.
Страница (форма) создания новой задачи.

Примеры запуска приложения.

На главной странице переходим по ссылке "Создать задачу" и в появившейся форме указываем загловок задачи (например Задача 1). Можно заполнить необязательные данные дат начала и завершения задачи в формате 2023-12-31. Нажимаем кнопку "Создать". Таким образом, целесообразно создать несколько задач (можно не выходя из формы создания задач), чтобы можно было их связать между собой.
Возвращаемся на главную страницу и при необходимости обновляем ее. Появляется список созданных задач. Для примера, перейдем по ссылке на заголовке любой из задач и перейдем в окно связывания выброанной задачи с другими задачами. В данном окне появится загловок выбранной задачи, список связанной с ней других задач (изначально пустой) и список задач, которые можно привязать к данной задаче.
По аналогии с блок-схемами можно сказать, что из выбранной задачи идут исходящие "стрелки" к связанным задачам.
Реализована логика, что от одной задаче к другой может быть только одна исходящая стрелка (в обратном направлении эти задачи можно связывать). также задачу невозможно связать саму с собой. Поэтому из списка несвязаннх задач сделаны соответствующий исключения.
Напротив каждой несвязанной задачи реализована кнопка обозначенная -->, которая переводит задачу в список связанных задач после обновления страницы. Нажимаем эту кнопку напротив задачи для связывания с текущей задачей и обновляем страницу. Видим, как список связанных задач пополнился одной задачей, а из списка несвязанных задач эта задача исчезла.
В списках задач, связанных с выбранной задачей, реализована кнопка обозначенная –x-. Данная кнопка удаляет связанность задач и соответствующая задача переходит в список несвязанных при обновлении страницы.
Нажимаем эту кнопку рядом с появившейся задачей в списке связанных задач и обновляем страницу. Видим, что задача вернулась в писок несвязанных задач.
Вверху страницы нажимаем "Главная страница" и возвращаемся на главную страницу приложения.
Переходим по ссылке "Создать контакт". В ней указывам ФИО контакта и нажимаем кнопку "Создать". Повторяем несколько раз операцию для создания нескольких контактов. Возвращаемся на главную старницу.
Выбираем из списка задач любую строчку и нажимаем напротив нее кнопку <>. Мы перешли на страницу связывания выбранной задачи (ее заголовок появляется вверху страницы) с контактами.
На данной странице два списка контактов: связанных с выбранной задачей (изначально пуст) и не связанных с задачей (т.к. одитн контакт можно связать с задачей многократно, но с разными ролями, то это полный список контактов). В нижнем списке контактов выбираем нужный конаткт и нажимаем напротив него кнопку -> и обновляем страницу. Контакт появился в списке связанных с выбранной задачей контактов. Рядом каждым связанным с задачей контактом появляется выпадающий список ролей (первоначально указано "выбрать роль"). Выбираем роль при выполнении задачи связанного контакта (например "исполнитель") и нажимаем кнопку U анпротив выпадающего списка ролей. Обновляем страницу и видим, что у связанного с задачей контакта появилась роль "исполнитель".

Выводы. Сравнение удобства использования различных ORM (Object-Relational Mapping) библиотек: Django ORM, SQLAlchemy и Tortoise ORM.

Реализация проекта показала ряд положительных и отрицательных моментов данных трех ORM библиотек.
Запросы и модели таблиц на Tortoise ORM строятся фактически по тем же правилам, что и в Django ORM (наибольшее отличие –  нет необходимости работать в запросах через атрибут класса objects). 
При этом Tortoise ORM по умолчанию является асихронной, а в Django ORM асихронность необходимо специально прописывать. Миграции схемы данных проще в Django ORM.
В Django ORM и Tortoise ORM в моделях реляционные связи один ко многим, многие ко многим и многие к одному прописываются в описании пол, что не очень удобно, когда поле нужно сделать и первичным ключом 
и ключом для связей с этой же или другими таблицами (прописывание в моделях реляционной связи таблицы с самой собой проблематична и с SQLAlchemy). SQLAlchemy в моделях отдельно от описания полей прописывается 
их реляционная связь с другими полями таблиц.
Для Django ORM и Tortoise ORM запросы по связанным таблицам (в один оператор) возможны только по реляционным связям, прописанным в моделях или через подзапросы. Что увеличивает объем кода. 
В нашем случае, при реализации таблицы универсального списка, где многие ко многим предполагаются для связывания любых таблиц.
В отличие от них в SQLAlchemy удобно связывать таблицы на уровне запроса операторами типа join любых таблиц по любым их полям (как в SQL). При этом есть, как left join, так и inner join. SQLAlchemy не является асихронной по умолчанию.
